<!DOCTYPE html>
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<html lang="en-US">
<head xmlns:og="http://ogp.me/ns#" xmlns:book="https://ogp.me/ns/book#">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Logic</title>
<meta name="Keywords" content="Authored in PreTeXt">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta property="og:type" content="book">
<meta property="book:title" content="Math 230-2">
<meta property="book:author" content="Aaron Greicius">
<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script><script>var runestoneMathReady = new Promise((resolve) => window.rsMathReady = resolve);
window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)']],
    tags: "none",
    tagSide: "right",
    tagIndent: ".8em",
    packages: {'[+]': ['base', 'extpfeil', 'ams', 'amscd', 'newcommand', 'knowl']}
  },
  options: {
    ignoreHtmlClass: "tex2jax_ignore|ignore-math",
    processHtmlClass: "process-math",
    renderActions: {
        findScript: [10, function (doc) {
            document.querySelectorAll('script[type^="math/tex"]').forEach(function(node) {
                var display = !!node.type.match(/; *mode=display/);
                var math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                var text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = {node: text, delim: '', n: 0};
                math.end = {node: text, delim: '', n: 0};
                doc.math.push(math);
            });
        }, '']
    },
  },
  chtml: {
    scale: 0.88,
    mtextInheritFont: true
  },
  loader: {
    load: ['input/asciimath', '[tex]/extpfeil', '[tex]/amscd', '[tex]/newcommand', '[pretext]/mathjaxknowl3.js'],
    paths: {pretext: "https://pretextbook.org/js/lib"},
  },
  startup: {
    pageReady() {
      return MathJax.startup.defaultPageReady().then(function () {
      console.log("in ready function");
      rsMathReady();
      }
    )}
},
};
</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script src="https://pretextbook.org/js/lib/jquery.min.js"></script><script src="https://pretextbook.org/js/lib/jquery.sticky.js"></script><script src="https://pretextbook.org/js/lib/jquery.espy.min.js"></script><script src="https://pretextbook.org/js/0.13/pretext.js"></script><script>miniversion=0.674</script><script src="https://pretextbook.org/js/0.13/pretext_add_on.js?x=1"></script><script src="https://pretextbook.org/js/lib/knowl.js"></script><!--knowl.js code controls Sage Cells within knowls--><script>sagecellEvalName='Evaluate (Sage)';
</script><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600,600italic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.4/pretext.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.4/pretext_add_on.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.4/banner_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.4/toc_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.4/knowls_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.4/style_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.4/colors_blue_red.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.4/setcolors.css" rel="stylesheet" type="text/css">
</head>
<body class="pretext-book ignore-math has-toc has-sidebar-left">
<a class="assistive" href="#content">Skip to main content</a><div id="latex-macros" class="hidden-content process-math" style="display:none"><span class="process-math">\(\newcommand{\Z}{{\mathbb Z}}
  \newcommand{\Q}{{\mathbb Q}}
  \newcommand{\R}{{\mathbb R}}
  \newcommand{\C}{{\mathbb C}}
  \newcommand{\T}{{\mathbb T}}
  \newcommand{\F}{{\mathbb F}}
  \newcommand{\HH}{{\mathbb H}}
  \newcommand{\compose}{\circ}
  \newcommand{\bolda}{{\mathbf a}}
  \newcommand{\boldb}{{\mathbf b}}
  \newcommand{\boldc}{{\mathbf c}}
  \newcommand{\boldd}{{\mathbf d}}
  \newcommand{\bolde}{{\mathbf e}}
  \newcommand{\boldi}{{\mathbf i}}
  \newcommand{\boldj}{{\mathbf j}}
  \newcommand{\boldk}{{\mathbf k}}
  \newcommand{\boldn}{{\mathbf n}}
  \newcommand{\boldp}{{\mathbf p}}
  \newcommand{\boldq}{{\mathbf q}}
  \newcommand{\boldr}{{\mathbf r}}
  \newcommand{\bolds}{{\mathbf s}}
  \newcommand{\boldt}{{\mathbf t}}
  \newcommand{\boldu}{{\mathbf u}}
  \newcommand{\boldv}{{\mathbf v}}
  \newcommand{\boldw}{{\mathbf w}}
  \newcommand{\boldx}{{\mathbf x}}
  \newcommand{\boldy}{{\mathbf y}}
  \newcommand{\boldz}{{\mathbf z}}
  \newcommand{\boldzero}{{\mathbf 0}}
  \newcommand{\boldmod}{\boldsymbol{ \bmod }}
  \newcommand{\boldT}{{\mathbf T}}
  \newcommand{\boldN}{{\mathbf N}}
  \newcommand{\boldB}{{\mathbf B}}
  \newcommand{\boldF}{{\mathbf F}}
  \newcommand{\boldS}{{\mathbf S}}
  \newcommand{\boldG}{{\mathbf G}}
  \newcommand{\boldK}{{\mathbf K}}
  \newcommand{\boldL}{{\mathbf L}}
  \DeclareMathOperator{\lcm}{lcm}
  \DeclareMathOperator{\Span}{span}
  \DeclareMathOperator{\tr}{tr}
  \DeclareMathOperator{\NS}{null}
  \DeclareMathOperator{\RS}{row}
  \DeclareMathOperator{\CS}{col}
  \DeclareMathOperator{\im}{im}
  \DeclareMathOperator{\range}{range}
  \DeclareMathOperator{\rank}{rank}
  \DeclareMathOperator{\nullity}{nullity}
  \DeclareMathOperator{\sign}{sign}
  \DeclareMathOperator{\Fix}{Fix}
  \DeclareMathOperator{\Aff}{Aff}
  \DeclareMathOperator{\Frac}{Frac}
  \DeclareMathOperator{\Ann}{Ann}
  \DeclareMathOperator{\Tor}{Tor}
  \DeclareMathOperator{\id}{id}
  \DeclareMathOperator{\mdeg}{mdeg}
  \DeclareMathOperator{\Lt}{Lt}
  \DeclareMathOperator{\Lc}{Lc}
  \DeclareMathOperator{\disc}{disc}
  \DeclareMathOperator{\Frob}{Frob}
  \DeclareMathOperator{\adj}{adj}
  \DeclareMathOperator{\curl}{curl}
  \DeclareMathOperator{\grad}{grad}
  \DeclareMathOperator{\diver}{div}
  \DeclareMathOperator{\flux}{flux}
  \newcommand{\surjects}{\twoheadrightarrow}
  \newcommand{\injects}{\hookrightarrow}
  \newcommand{\bijects}{\leftrightarrow}
  \newcommand{\isomto}{\overset{\sim}{\rightarrow}}
  \newcommand{\floor}[1]{\lfloor#1\rfloor}
  \newcommand{\ceiling}[1]{\left\lceil#1\right\rceil}
  \newcommand{\mclass}[2][m]{[#2]_{#1}}
  \newcommand{\val}[2][]{\left\lvert #2\right\rvert_{#1}}
  \newcommand{\abs}[2][]{\left\lvert #2\right\rvert_{#1}}
  \newcommand{\valuation}[2][]{\left\lvert #2\right\rvert_{#1}}
  \newcommand{\norm}[1]{\left\lVert#1\right\rVert}
  \newcommand{\anpoly}{a_nx^n+a_{n-1}x^{n-1}\cdots +a_1x+a_0}
  \newcommand{\anmonic}{x^n+a_{n-1}x^{n-1}\cdots +a_1x+a_0}
  \newcommand{\bmpoly}{b_mx^m+b_{m-1}x^{m-1}\cdots +b_1x+b_0}
  \newcommand{\pder}[2]{\frac{\partial#1}{\partial#2}}
  \newcommand{\normalin}{\trianglelefteq}
  \newcommand{\angvec}[1]{\langle #1\rangle}
  \newcommand{\varpoly}[2]{#1_{#2}x^{#2}+#1_{#2-1}x^{#2-1}\cdots +#1_1x+#1_0}
  \newcommand{\varpower}[1][a]{#1_0+#1_1x+#1_1x^2+\cdots}
  \newcommand{\limasto}[2][x]{\lim_{#1\rightarrow #2}}
\newcommand{\lt}{&lt;}
\newcommand{\gt}{&gt;}
\newcommand{\amp}{&amp;}
\definecolor{fillinmathshade}{gray}{0.9}
\newcommand{\fillinmath}[1]{\mathchoice{\colorbox{fillinmathshade}{$\displaystyle     \phantom{\,#1\,}$}}{\colorbox{fillinmathshade}{$\textstyle        \phantom{\,#1\,}$}}{\colorbox{fillinmathshade}{$\scriptstyle      \phantom{\,#1\,}$}}{\colorbox{fillinmathshade}{$\scriptscriptstyle\phantom{\,#1\,}$}}}
\)</span></div>
<header id="masthead" class="smallbuttons"><div class="banner"><div class="container">
<a id="logo-link" href="" target="_blank"><img src="external/images/tcu14_ppt_ch16.png" alt="Logo image"></a><div class="title-container">
<h1 class="heading"><a href="kursobjekt.html"><span class="title">Math 230-2:</span> <span class="subtitle">Kursobjekt</span></a></h1>
<p class="byline">Aaron Greicius</p>
</div>
</div></div>
<nav id="primary-navbar" class="navbar"><div class="container">
<div class="navbar-top-buttons">
<button class="sidebar-left-toggle-button button active" aria-label="Show or hide table of contents sidebar">Contents</button><div class="tree-nav toolbar toolbar-divisor-3">
<a class="index-button toolbar-item button" href="index-1.html" title="Index">Index</a><span class="threebuttons"><a id="previousbutton" class="previous-button toolbar-item button" href="s_sets_functions.html" title="Previous">Prev</a><a id="upbutton" class="up-button button toolbar-item" href="c_foundations.html" title="Up">Up</a><a id="nextbutton" class="next-button button toolbar-item" href="c_multiple_integrals.html" title="Next">Next</a></span>
</div>
</div>
<div class="navbar-bottom-buttons toolbar toolbar-divisor-4">
<button class="sidebar-left-toggle-button button toolbar-item active">Contents</button><a class="previous-button toolbar-item button" href="s_sets_functions.html" title="Previous">Prev</a><a class="up-button button toolbar-item" href="c_foundations.html" title="Up">Up</a><a class="next-button button toolbar-item" href="c_multiple_integrals.html" title="Next">Next</a>
</div>
</div></nav></header><div class="page">
<div id="sidebar-left" class="sidebar" role="navigation"><div class="sidebar-content">
<nav id="toc"><ul>
<li class="link frontmatter">
<a href="meta_frontmatter.html" data-scroll="meta_frontmatter" class="internal"><span class="title">Front Matter</span></a><ul><li><a href="colophon-1.html" data-scroll="colophon-1" class="internal">Colophon</a></li></ul>
</li>
<li class="link">
<a href="c_foundations.html" data-scroll="c_foundations" class="internal"><span class="codenumber">0</span> <span class="title">Foundations</span></a><ul>
<li><a href="s_sets_functions.html" data-scroll="s_sets_functions" class="internal">Sets and functions</a></li>
<li><a href="s_logic.html" data-scroll="s_logic" class="active">Logic</a></li>
</ul>
</li>
<li class="link">
<a href="c_multiple_integrals.html" data-scroll="c_multiple_integrals" class="internal"><span class="codenumber">1</span> <span class="title">Multiple integrals</span></a><ul>
<li><a href="s_double_integrals_rect.html" data-scroll="s_double_integrals_rect" class="internal">Double integrals over rectangles</a></li>
<li><a href="s_double_iterated_integrals.html" data-scroll="s_double_iterated_integrals" class="internal">Iterated integrals and Fubini's theorem</a></li>
<li><a href="s_double_integrals_gen.html" data-scroll="s_double_integrals_gen" class="internal">Double integrals over general regions</a></li>
<li><a href="s_double_integrals_area.html" data-scroll="s_double_integrals_area" class="internal">Area of planar regions and average value</a></li>
<li><a href="s_triple_integrals.html" data-scroll="s_triple_integrals" class="internal">Triple integrals</a></li>
</ul>
</li>
<li class="link backmatter"><a href="backmatter-1.html" data-scroll="backmatter-1" class="internal"><span class="title">Back Matter</span></a></li>
<li class="link"><a href="appendix-notation.html" data-scroll="appendix-notation" class="internal"><span class="codenumber">A</span> <span class="title">Notation</span></a></li>
<li class="link"><a href="appendix-defs.html" data-scroll="appendix-defs" class="internal"><span class="codenumber">B</span> <span class="title">Definitions</span></a></li>
<li class="link"><a href="appendix-thms.html" data-scroll="appendix-thms" class="internal"><span class="codenumber">C</span> <span class="title">Theory and procedures</span></a></li>
<li class="link"><a href="appendix-egs.html" data-scroll="appendix-egs" class="internal"><span class="codenumber">D</span> <span class="title">Examples</span></a></li>
<li class="link"><a href="appendix-sage.html" data-scroll="appendix-sage" class="internal"><span class="codenumber">E</span> <span class="title">Sage examples</span></a></li>
<li class="link"><a href="index-1.html" data-scroll="index-1" class="internal"><span class="title">Index</span></a></li>
</ul></nav><div class="extras"><nav><a class="pretext-link" href="https://pretextbook.org">Authored in PreTeXt</a><a href="https://www.mathjax.org"><img title="Powered by MathJax" src="https://www.mathjax.org/badge/badge.gif" alt="Powered by MathJax"></a></nav></div>
</div></div>
<main class="main"><div id="content" class="pretext-content"><section class="section" id="s_logic"><h2 class="heading hide-type">
<span class="type">Section</span> <span class="codenumber">0.2</span> <span class="title">Logic</span>
</h2>
<section class="introduction" id="introduction-2"><p id="p-51">When dealing with mathematical statements and arguments, we must pay close attention to logical structure. This section addresses Different logical connectors give rise to different proof approaches. For the rest of this section, the symbols <span class="process-math">\(\mathcal{P}\)</span> and <span class="process-math">\(\mathcal{Q}\)</span> will stand for propositions.</p></section><section class="subsection" id="ss_propositional_calculus"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">0.2.1</span> <span class="title">Propositional logic</span>
</h3>
<p id="p-52">A <em class="emphasis">proposition</em> is a sentence that is either true or false. We build <em class="emphasis">compound propositions</em> from component propositions using <em class="emphasis">logical operators</em> (or <em class="emphasis">logical connectors</em>); the truth value of the compound proposition is defined as a function of the truth values of the component propositions.</p>
<article class="definition definition-like" id="d_logical_ops"><h4 class="heading">
<span class="type">Definition</span><span class="space"> </span><span class="codenumber">0.2.1</span><span class="period">.</span><span class="space"> </span><span class="title">Logical operators.</span>
</h4>
<ul id="p-53" class="disc">
<li id="li-13">
<span class="heading"><span class="title">Negation.</span></span><p id="p-54">Given a proposition <span class="process-math">\(\mathcal{P}\text{,}\)</span> the <dfn class="terminology">negation of <span class="process-math">\(\mathcal{P}\)</span></dfn> is the proposition “Not <span class="process-math">\(\mathcal{P}\)</span>”, denoted <span class="process-math">\(\neg\mathcal{P}\)</span> in logical notation, the truth value of which is defined as follows: <span class="process-math">\(\neg\mathcal{P}\)</span> is true exactly when <span class="process-math">\(\mathcal{P}\)</span> is false.</p>
</li>
<li id="li-14">
<span class="heading"><span class="title">Conjunction (logical and).</span></span><p id="p-55">Given propositions <span class="process-math">\(\mathcal{P}\)</span> and <span class="process-math">\(\mathcal{Q}\text{,}\)</span> their <dfn class="terminology">conjuction</dfn> is the proposition “<span class="process-math">\(\mathcal{P}\)</span> and <span class="process-math">\(\mathcal{Q}\)</span>”, denoted <span class="process-math">\(\mathcal{P}\land \mathcal{Q}\)</span> in logical notation, the truth value of which is defined as follows:  <span class="process-math">\(\mathcal{P}\land\mathcal{Q}\)</span> is true when both <span class="process-math">\(\mathcal{P}\)</span> and <span class="process-math">\(\mathcal{Q}\)</span> are true, and false otherwise.</p>
</li>
<li id="li-15">
<span class="heading"><span class="title">Disjunction (logical or).</span></span><p id="p-56">Given propositions <span class="process-math">\(\mathcal{P}\)</span> and <span class="process-math">\(\mathcal{Q}\text{,}\)</span> their <dfn class="terminology">disjunction</dfn> is the proposition “<span class="process-math">\(\mathcal{P}\)</span> or <span class="process-math">\(\mathcal{Q}\)</span>”, denoted <span class="process-math">\(\mathcal{P}\lor \mathcal{Q}\)</span> in logical notation, the truth value of which is defined as follows: <span class="process-math">\(\mathcal{P}\lor \mathcal{Q}\)</span> is true when at least one of <span class="process-math">\(\mathcal{P}\)</span> and <span class="process-math">\(\mathcal{Q}\)</span> is true, and false otherwise.</p>
</li>
<li id="li-16">
<span class="heading"><span class="title">Logical implication (if-then).</span></span><p id="p-57">Given propositions <span class="process-math">\(\mathcal{P}\)</span> and <span class="process-math">\(\mathcal{Q}\text{,}\)</span> the proposition “If <span class="process-math">\(\mathcal{P}\text{,}\)</span> then <span class="process-math">\(\mathcal{Q}\)</span>”, denoted <span class="process-math">\(\mathcal{P}\implies\mathcal{Q}\)</span> in logical notation, is called an <dfn class="terminology">implication</dfn>, and its truth value is defined as follows: <span class="process-math">\(\mathcal{P}\implies\mathcal{Q}\)</span> is false when <span class="process-math">\(\mathcal{P}\)</span> is true and <span class="process-math">\(\mathcal{Q}\)</span> is false, and true otherwise.</p>
</li>
<li id="li-17">
<span class="heading"><span class="title">Logical equivalence (if and only if).</span></span><p id="p-58">Given propositions <span class="process-math">\(\mathcal{P}\)</span> and <span class="process-math">\(\mathcal{Q}\text{,}\)</span> the proposition “<span class="process-math">\(\mathcal{P}\)</span> if and only if <span class="process-math">\(\mathcal{Q}\)</span>”, denoted <span class="process-math">\(\mathcal{P}\iff\mathcal{Q}\)</span> in logical notation, is called an <dfn class="terminology">equivalence</dfn>, and its truth value is defined as follows: <span class="process-math">\(\mathcal{P}\iff \mathcal{Q}\)</span> is true when <span class="process-math">\(\mathcal{P}\)</span> and <span class="process-math">\(\mathcal{Q}\)</span> have the same truth value, and false otherwise. We say <span class="process-math">\(\mathcal{P}\)</span> and <span class="process-math">\(\mathcal{Q}\)</span> are <dfn class="terminology">logically equivalent</dfn> when <span class="process-math">\(\mathcal{P}\iff \mathcal{Q}\)</span> is true.</p>
</li>
</ul></article><article class="remark remark-like" id="rm_truth_tables"><h4 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">0.2.2</span><span class="period">.</span>
</h4>
<p id="p-59">A <em class="emphasis">truth table</em> of a compound proposition <span class="process-math">\(\mathcal{P}\)</span> is a concise way of displaying how the truth value of <span class="process-math">\(\mathcal{P}\)</span> depends on the truth values of its component propositions. It contains one row for each possible truth assignment of the component propositions.  As illustration, we give the truth tables for the logical operators defined above:</p>
<div class="displaymath process-math" data-contains-math-knowls="" id="md-8">
\begin{align*}
\amp\begin{array}{c||c}\mathcal{P}\amp\neg\mathcal{P} \\
\hline T\amp F\\F\amp T\end{array} \amp \amp \begin{array}{c|c||c}\mathcal{P}\amp\mathcal{Q}\amp\mathcal{P}\land\mathcal{Q} \\
\hline T\amp T\amp T\\T\amp F\amp F\\ F\amp T\amp F\\ F\amp F\amp F\end{array}
\amp \amp \begin{array}{c|c||c}\mathcal{P}\amp\mathcal{Q}\amp\mathcal{P}\lor\mathcal{Q} \\
\hline T\amp T\amp T\\T\amp F\amp T\\ F\amp T\amp T\\ F\amp F\amp F\end{array}\\
\amp
\begin{array}{c|c||c}\mathcal{P}\amp\mathcal{Q}\amp\mathcal{P}\implies\mathcal{Q} \\
\hline T\amp T\amp T\\T\amp F\amp F\\ F\amp T\amp T\\ F\amp F\amp T\end{array}
\amp \amp \begin{array}{c|c||c}\mathcal{P}\amp\mathcal{Q}\amp\mathcal{P}\iff\mathcal{Q} \\
\hline T\amp T\amp T\\T\amp F\amp F\\ F\amp T\amp F\\ F\amp F\amp T\end{array}
\end{align*}
</div></article><article class="example example-like" id="example-5"><a href="" data-knowl="" class="id-ref example-knowl original" data-refid="hk-example-5"><h4 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">0.2.3</span><span class="period">.</span>
</h4></a></article><div class="hidden-content tex2jax_ignore" id="hk-example-5"><article class="example example-like"><p id="p-60">Use a truth table to find all truth value assignments of <span class="process-math">\(\mathcal{P}\)</span> and <span class="process-math">\(\mathcal{Q}\)</span> making the compound proposition</p>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
\neg\mathcal{P}\implies (\mathcal{Q}\implies P)
\end{equation*}
</div>
<p class="continuation">false.</p>
<div class="solutions">
<a href="" data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-1" id="solution-1"><span class="type">Solution</span><span class="period">.</span></a><div class="hidden-content tex2jax_ignore" id="hk-solution-1"><div class="solution solution-like">
<p id="p-61">We construct a truth table with columns for <span class="process-math">\(\mathcal{P}\text{,}\)</span> <span class="process-math">\(\mathcal{Q}\text{,}\)</span> <span class="process-math">\(\neg\mathcal{P}\text{,}\)</span> <span class="process-math">\(\mathcal{Q\implies P}\text{,}\)</span> and <span class="process-math">\(\neg\mathcal{P}\implies (\mathcal{Q}\implies P)\text{:}\)</span></p>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
\begin{array}{c|c|c|c||c}\mathcal{P}\amp\mathcal{Q}\amp\neg\mathcal{P}\amp \mathcal{Q}\implies \mathcal{P}\amp \neg\mathcal{P}\implies(\mathcal{Q}\implies \mathcal{P}) \\
\hline T\amp T\amp F\amp T\amp T\\T\amp F\amp F\amp T\amp T\\ F\amp T\amp T\amp F\amp F\\ F\amp F\amp T\amp T\amp T\end{array}\text{.}
\end{equation*}
</div>
<p class="continuation">We conclude that <span class="process-math">\(\neg\mathcal{P}\implies (\mathcal{Q}\implies P)\)</span> is false exactly when <span class="process-math">\(\mathcal{P}\)</span> is false and <span class="process-math">\(\mathcal{Q}\)</span> is true. (It follows that <span class="process-math">\(\neg\mathcal{P}\implies (\mathcal{Q}\implies P)\)</span> is equivalent to <span class="process-math">\(Q\implies P\text{.}\)</span> )</p>
</div></div>
</div></article></div>
<article class="remark remark-like" id="rm_logic_vs_vernacular"><h4 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">0.2.4</span><span class="period">.</span>
</h4>
<p id="p-62">Our definitions of the logical operators above are chosen to agree with their usage in a very particular type of discourse: namely, <em class="emphasis">mathematical</em> discourse. They do not always agree with their use in natural language: hence the modifier “logical” in their titles.</p>
<p id="p-63">For example, disjunctions in natural language of the form “<span class="process-math">\(\mathcal{P}\)</span> or <span class="process-math">\(\mathcal{Q}\)</span>” are often understood to be true when <span class="process-math">\(\mathcal{P}\)</span> is true or <span class="process-math">\(\mathcal{Q}\)</span> is true, <em class="emphasis">but not both</em>. This notion of disjunction is called the <em class="emphasis">exclusive or</em> in logic, in contrast to the standard logical or.</p>
<p id="p-64">Similarly, according to our definition, the implication “If the President of the US is a dog, then the Vice President of the US is a cat” is true, since the proposition “The President of the US is a dog” is false. (In logic we say the implication is <em class="emphasis">vacuously true</em> in this case.) However, working outside of our logical definitions of truth value, we may have been inclined to treat this implication as false, since both “The President of the US is a dog” and “The Vice President of the US is a cat” are false.</p></article></section><section class="subsection" id="ss_predicate_logic"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">0.2.2</span> <span class="title">Predicate logic</span>
</h3>
<p id="p-65">Propositions like “All humans are mortal” and “Every positive real number has a square-root” are modeled in logic in the form “For all <span class="process-math">\(x\text{,}\)</span> <span class="process-math">\(P(x)\)</span>” and “For all <span class="process-math">\(r\text{,}\)</span> there exists an <span class="process-math">\(s\)</span> such that <span class="process-math">\(Q(r,s)\)</span>”, where <span class="process-math">\(P(x)\)</span> stands for the phrase “<span class="process-math">\(x\)</span> is mortal” and <span class="process-math">\(Q(r,s)\)</span> stands for the phrase “<span class="process-math">\(s\)</span> is a square-root of <span class="process-math">\(r\)</span>”. Observe that <span class="process-math">\(P(x)\)</span> and <span class="process-math">\(Q(r,s)\)</span> on their own are not propositions; there is no truth value to “<span class="process-math">\(x\)</span> is mortal” or “<span class="process-math">\(s\)</span> is a square-root of <span class="process-math">\(r\)</span>”. Instead, we think of <span class="process-math">\(P(x)\)</span> and <span class="process-math">\(Q(r,s)\)</span> as <em class="emphasis">functions</em> which return propositions when evaluated at a specific choice for <span class="process-math">\(x\text{,}\)</span> or for <span class="process-math">\(r\)</span> and <span class="process-math">\(s\text{.}\)</span> For example, evaluating <span class="process-math">\(P(x)\)</span> at <span class="process-math">\(x=\text{Aaron Greicius}\)</span> yields the proposition “Aaron Greicius is mortal”, which happens to be true at the time of writing. Similarly evaluating <span class="process-math">\(Q(r,s)\)</span> at  <span class="process-math">\(r=2, s=11\)</span> yields the proposition “<span class="process-math">\(11\)</span> is a square-root of 2”, which happens to be false. In logic  <span class="process-math">\(P(x)\)</span> and <span class="process-math">\(Q(r,s)\)</span> are called <em class="emphasis">propositional functions</em> (also called  <em class="emphasis">predicates</em>): functions whose outputs are propositions.</p>
<p id="p-66">The propositions “For all <span class="process-math">\(x\text{,}\)</span> <span class="process-math">\(P(x)\)</span>” and “For all <span class="process-math">\(r\text{,}\)</span> there exists an <span class="process-math">\(s\)</span> such that <span class="process-math">\(Q(r,s)\)</span>” are obtained from <span class="process-math">\(P(x)\)</span> and <span class="process-math">\(Q(r,s)\)</span> by <em class="emphasis">bounding</em> them with a series of <em class="emphasis">quantifiers</em> (e.g., “for all <span class="process-math">\(x\)</span>”, “there exists an <span class="process-math">\(s\)</span>”). The definition below allows us to assign truth values to such propositions.</p>
<article class="definition definition-like" id="d_quantifiers"><h4 class="heading">
<span class="type">Definition</span><span class="space"> </span><span class="codenumber">0.2.5</span><span class="period">.</span>
</h4>
<p id="p-67">Let <span class="process-math">\(D\)</span> be a set, and let <span class="process-math">\(P\)</span> be a propositional function that assigns to all elements <span class="process-math">\(d\in D\)</span> the proposition <span class="process-math">\(P(d)\text{.}\)</span> The set <span class="process-math">\(D\)</span> is called the <dfn class="terminology">domain of discourse</dfn> of <span class="process-math">\(P\text{.}\)</span></p>
<ul class="disc">
<li id="li-18">
<span class="heading"><span class="title">Universal quantifier.</span></span><p id="p-68">The proposition “For all <span class="process-math">\(x\)</span> in <span class="process-math">\(D\text{,}\)</span> <span class="process-math">\(P(x)\)</span>”, denoted <span class="process-math">\(\forall x P(x)\)</span> in logical notation, is called a <dfn class="terminology">universal quantification</dfn>, and its truth value is defined as follows: <span class="process-math">\(\forall x P(x)\)</span> is true if for all elements <span class="process-math">\(d\)</span> of <span class="process-math">\(D\text{,}\)</span> the proposition <span class="process-math">\(P(d)\)</span> is true; it is false if there is some <span class="process-math">\(d\in D\)</span> such that <span class="process-math">\(P(d)\)</span> is false.</p>
</li>
<li id="li-19">
<span class="heading"><span class="title">Existential quantifier.</span></span><p id="p-69">The proposition “There exists an <span class="process-math">\(x\)</span> in <span class="process-math">\(D\)</span> such that <span class="process-math">\(P(x)\)</span>”, denoted <span class="process-math">\(\exists x P(x)\)</span> in logical notation, is called an <dfn class="terminology">existential quantification</dfn>, and its truth value is defined as follows: <span class="process-math">\(\exists x P(x)\)</span> is true if there is some element <span class="process-math">\(d\)</span> of <span class="process-math">\(D\)</span> for which the proposition <span class="process-math">\(P(d)\)</span> is true; it is false if <span class="process-math">\(P(d)\)</span> is false for all <span class="process-math">\(d\in D\text{.}\)</span></p>
</li>
</ul></article><article class="remark remark-like" id="rm_domain_discourse"><h4 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">0.2.6</span><span class="period">.</span><span class="space"> </span><span class="title">Truth depends on domain of discourse.</span>
</h4>
<p id="p-70">Just as a function is not properly defined before its domain is specified, we do not have a well-defined propositional function, nor well-defined truth values of propositions built from this propositional function, until its domain of discourse is given.</p>
<p id="p-71">For example, let <span class="process-math">\(P(x)\)</span> be “x&gt;0”. If we declare <span class="process-math">\(D=(0,\infty)\text{,}\)</span> then the proposition <span class="process-math">\(\forall x P(x)\)</span> is true, since by definition every <span class="process-math">\(d\in (0,\infty)\)</span> is positive. On the other hand,  if we declare <span class="process-math">\(D=\R\text{,}\)</span> the proposition <span class="process-math">\(\forall x P(x)\)</span> is false since not all elements of <span class="process-math">\(\R\)</span> are positive: indeed, <span class="process-math">\(-1\)</span> is negative, making <span class="process-math">\(P(-1)\)</span> false.</p>
<p id="p-72">Because of the important role played by the domain of discourse <span class="process-math">\(D\text{,}\)</span> we sometimes include it in our quantifier expressions: e.g., <span class="process-math">\(\forall x\in D P(x)\text{,}\)</span> <span class="process-math">\(\exists x\in D P(x)\text{.}\)</span>  Using this convention allows us to see more immediately that  <span class="process-math">\(\forall\, x\in (0,\infty)\, P(x)\)</span> is true and <span class="process-math">\(\forall\, x\in\mathbb{R}\, P(x)\)</span> is false.</p></article><article class="example example-like" id="ex_model_quant"><a href="" data-knowl="" class="id-ref example-knowl original" data-refid="hk-ex_model_quant"><h4 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">0.2.7</span><span class="period">.</span><span class="space"> </span><span class="title">Modeling “Every positive number has a square-root”.</span>
</h4></a></article><div class="hidden-content tex2jax_ignore" id="hk-ex_model_quant"><article class="example example-like"><p id="p-73">Model the sentence “Every positive real number has a square-root” in the form <span class="process-math">\(\forall x P(x)\text{,}\)</span> where <span class="process-math">\(P\)</span> is a propositional function with domain of discourse <span class="process-math">\(D=\R\text{.}\)</span> Determine the truth value of <span class="process-math">\(\forall x\, P(x)\)</span> using <a href="" class="xref" data-knowl="./knowl/d_quantifiers.html" title="Definition 0.2.5">Definition 0.2.5</a>.</p>
<div class="solutions">
<a href="" data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-2" id="solution-2"><span class="type">Solution</span><span class="period">.</span></a><div class="hidden-content tex2jax_ignore" id="hk-solution-2"><div class="solution solution-like">
<p id="p-74">Fix our domain of discourse to be <span class="process-math">\(D=\R\text{.}\)</span> For any <span class="process-math">\(r,s\in \R\text{,}\)</span> let <span class="process-math">\(Q(r,s)\)</span> be the proposition that <span class="process-math">\(s\)</span> is a square-root of <span class="process-math">\(r\text{.}\)</span> Define <span class="process-math">\(P(x)\)</span> to be the propositional function</p>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
x&gt;0 \implies \exists y\, Q(x,y)\text{.}
\end{equation*}
</div>
<p class="continuation">Thus for any <span class="process-math">\(r\in\R\text{,}\)</span> <span class="process-math">\(P(r)\)</span> is the proposition that if <span class="process-math">\(r\)</span> is positive, then <span class="process-math">\(r\)</span> has a square-root. It follows that <span class="process-math">\(\forall x\in\R\, P(x)\)</span> is the proposition that for all real numbers <span class="process-math">\(x\text{,}\)</span> if <span class="process-math">\(x\)</span> is positive, then  <span class="process-math">\(x\)</span> has a square-root. This is clearly equivalent to the proposition that every positive real number has a square-root, as desired.</p>
<p id="p-75">Lastly, we use <a href="" class="xref" data-knowl="./knowl/d_quantifiers.html" title="Definition 0.2.5">Definition 0.2.5</a> to show <span class="process-math">\(\forall x\in \R\, P(x)\)</span> is true. Take any <span class="process-math">\(r\in \R\text{.}\)</span> The real number <span class="process-math">\(r\)</span> is either positive or not positive. If <span class="process-math">\(r\)</span> is not positive, then <span class="process-math">\(r&gt;0\)</span> is false and hence <span class="process-math">\(P(r)\text{,}\)</span> which is the implication <span class="process-math">\(r&gt;0\implies \exists y\, Q(r,y)\text{,}\)</span> is true vacuously.  If <span class="process-math">\(r\)</span> is positive, then <span class="process-math">\(r&gt;0\)</span> is true, and <span class="process-math">\(\exists y\, Q(r,y)\)</span> is true, since <span class="process-math">\(r\)</span> has a square-root in this case: namely, <span class="process-math">\(\sqrt{r}\text{.}\)</span> But if <span class="process-math">\(r&gt;0\)</span> is true and <span class="process-math">\(\exists y\, Q(r,y)\)</span> is true, then the implication <span class="process-math">\(r&gt;0\implies \exists y\, Q(r,y)\)</span> is true. We have proved <span class="process-math">\(P(r)\)</span> is true for all <span class="process-math">\(r\in \R\text{.}\)</span> Thus <span class="process-math">\(\forall x\in\R\, P(x)\)</span> is true.</p>
</div></div>
</div></article></div>
<article class="warning remark-like" id="warning_order_quantifiers"><h4 class="heading">
<span class="type">Warning</span><span class="space"> </span><span class="codenumber">0.2.8</span><span class="period">.</span><span class="space"> </span><span class="title">Order of quantifiers matters.</span>
</h4>
<p id="p-76">As <a href="" class="xref" data-knowl="./knowl/ex_model_quant.html" title='Example 0.2.7: Modeling "Every positive number has a square-root"'>Example 0.2.7</a> illustrates, we can take a propositional function <span class="process-math">\(Q(x,y)\)</span> in two variables and quantify one of the two variables to obtain a propositional function in one variable: e.g., <span class="process-math">\(P(x)=\exists y\, Q(x,y)\)</span> or <span class="process-math">\(R(y)=\forall x\, Q(x,y)\text{.}\)</span> Proceeding in this manner we engender propositions involving sequences of quantifiers. Mark well that the order of the quantifiers in such sequences is important!</p>
<p id="p-77">For example, letting <span class="process-math">\(Q(x,y)\)</span> be “<span class="process-math">\(y\)</span> is a square-root of <span class="process-math">\(y\)</span>” with domain of discourse <span class="process-math">\(D=(0,\infty)\text{.}\)</span> The proposition <span class="process-math">\(\forall x\in\R\, \exists y\in\R\, Q(x,y)\)</span> says that every positive real number has a positive square-root (true); the proposition <span class="process-math">\(\exists y\in\R\, \forall x\in\R\, Q(x,y)\)</span> says that there is a positive real number that is the square-root of all real numbers (false).</p>
<p id="p-78">In general to “unpack” a sequence of quantifiers we start from the leftmost quantifier and proceed to the right.</p></article><article class="remark remark-like" id="rm_negating_quantifiers"><h4 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">0.2.9</span><span class="period">.</span><span class="space"> </span><span class="title">Negating quantifiers.</span>
</h4>
<p id="p-79">Let <span class="process-math">\(P(x)\)</span> be a propositional function with domain of discourse <span class="process-math">\(D\text{.}\)</span> According to <a href="" class="xref" data-knowl="./knowl/d_quantifiers.html" title="Definition 0.2.5">Definition 0.2.5</a> a universal quantification <span class="process-math">\(\forall x\, P(x)\)</span> is false if it is <em class="emphasis">not the case</em> that <span class="process-math">\(P(d)\)</span> is true for all for all <span class="process-math">\(d\in D\text{;}\)</span> that is, if there is some <span class="process-math">\(d\in D\)</span> such that <span class="process-math">\(P(d)\)</span> is false. Letting <span class="process-math">\(\neg P(x)\)</span> be the propositional function defined as <span class="process-math">\(\neg P(d)\)</span> for all <span class="process-math">\(d\in D\text{,}\)</span> we see that <span class="process-math">\(\forall x\,  P(x) \)</span> is false if and only if <span class="process-math">\(\exists x\, \neg P(x)\)</span> is true. This proves the equivalence</p>
<div class="displaymath process-math" data-contains-math-knowls="./knowl/d_quantifiers.html">
\begin{equation*}
\neg\forall x\, P(x)\iff \exists x\, \neg P(x)\text{.}
\end{equation*}
</div>
<p class="continuation">Similarly, we have</p>
<div class="displaymath process-math" data-contains-math-knowls="./knowl/d_quantifiers.html">
\begin{equation*}
\neg\exists x\, P(x)\iff \forall x\, \neg P(x)\text{.}
\end{equation*}
</div>
<p class="continuation">These equivalences can be understood as rules of negating quantifier statements. They can be summarized as follow: “swap quantifiers and negate the predicate.”</p></article><p id="p-80">The example below taken from calculus nicely illustrates how to negate  a proposition that involves a sequence of quantifiers.</p>
<article class="example example-like" id="ex_limit_doesnt_exist"><a href="" data-knowl="" class="id-ref example-knowl original" data-refid="hk-ex_limit_doesnt_exist"><h4 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">0.2.10</span><span class="period">.</span><span class="space"> </span><span class="title">The limit does not exist.</span>
</h4></a></article><div class="hidden-content tex2jax_ignore" id="hk-ex_limit_doesnt_exist"><article class="example example-like"><p id="p-81">Let <span class="process-math">\(f(x)\)</span> be a function with domain <span class="process-math">\(\R\text{,}\)</span> and let <span class="process-math">\(c\in \R\)</span> be a point of this domain. By definition, the proposition that <span class="process-math">\(\lim\limits_{x\to c}f(x)\)</span> exists is equivalent to the following proposition:</p>
<div class="displaymath process-math" data-contains-math-knowls="" id="eq_proposition">
\begin{equation}
\exists L\in\R\,  \forall \epsilon \gt 0\, \exists \delta \gt0\,  \forall x\in\mathbb{R}\ (\val{x-c}\lt\delta\implies \val{f(x)-L}\lt\epsilon)\text{.}\tag{0.2.1}
\end{equation}
</div>
<p class="continuation">(We made a number of shortcuts in our logical notation above (e.g. <span class="process-math">\(\forall \epsilon\gt 0\text{,}\)</span> <span class="process-math">\(\exists\delta\gt 0\)</span>) in order to simplify the expression somewhat; the intended meaning should still be clear. )</p>
<p id="p-82">Use the negation rules described in <a href="" class="xref" data-knowl="./knowl/rm_negating_quantifiers.html" title="Remark 0.2.9: Negating quantifiers">Negating quantifiers</a> to derive a similar proposition equivalent to the statement that <span class="process-math">\(\lim\limits_{x\to c}f(x)\)</span> do not exist.</p>
<div class="solutions">
<a href="" data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-3" id="solution-3"><span class="type">Solution</span><span class="period">.</span></a><div class="hidden-content tex2jax_ignore" id="hk-solution-3"><div class="solution solution-like">
<p id="p-83">Let <span class="process-math">\(\mathcal{P}\)</span> be the proposition in <a href="" class="xref" data-knowl="./knowl/eq_proposition.html" title="Equation 0.2.1">(0.2.1)</a>. Using the negation rules in series, we derive the <em class="emphasis">chain of equivalences</em>  below. We've added parentheses to emphasize what is being negated at each step. Note how a quantifiers are “swapped” each time we pass the negation to the right.</p>
<div class="displaymath process-math" data-contains-math-knowls="./knowl/eq_proposition.html" id="md-9">
\begin{align*}
\neg\mathcal{P}\amp\iff \forall L\in\R\,  \neg\left(\forall \epsilon \gt 0\, \exists \delta \gt0\,  \forall x\in\mathbb{R}\ (\val{x-c}\lt\delta\implies \val{f(x)-L}\lt\epsilon) \right)\\
\amp\iff  \forall L\in\R\,  \exists \epsilon \gt 0\, \neg\left( \exists \delta \gt0\,  \forall x\in\mathbb{R}\ (\val{x-c}\lt\delta\implies \val{f(x)-L}\lt\epsilon) \right)\\
\amp\iff  \forall L\in\R\,  \exists \epsilon \gt 0\,  \forall \delta \gt0\, \neg\left( \forall x\in\mathbb{R}\ (\val{x-c}\lt\delta\implies \val{f(x)-L}\lt\epsilon) \right)\\
\amp\iff  \forall L\in\R\,  \exists \epsilon \gt 0\,  \forall \delta \gt0\, \exists x\in\mathbb{R}\ \neg (\val{x-c}\lt\delta\implies \val{f(x)-L}\lt\epsilon)\\
\amp\iff  \forall L\in\R\,  \exists \epsilon \gt 0\,  \forall \delta \gt0\, \exists x\in\mathbb{R}\ (\val{x-c}\lt\delta \text{ and } \val{f(x)-L}\not\lt\epsilon)\text{.}
\end{align*}
</div>
<p class="continuation">(The last link in our chain uses the fact that <span class="process-math">\(\neg(\mathcal{Q}\implies\mathcal{R})\)</span> is equivalent to <span class="process-math">\(\mathcal{Q}\land\neg\mathcal{R}\text{,}\)</span> as a truth table easily shows.) Translating back into English, we conclude that the limit not existing (<span class="process-math">\(\neg\mathcal{P}\)</span>) is equivalent to the following: for every <span class="process-math">\(L\in \mathbb{R}\)</span> there is an <span class="process-math">\(\epsilon\gt 0\)</span> such that for all <span class="process-math">\(\delta\gt 0\)</span> there exists an <span class="process-math">\(x\in\mathbb{R}\)</span> satisfying <span class="process-math">\(\val{x-c}\lt \delta\)</span> and <span class="process-math">\(\val{f(x)-L}\not\gt\epsilon\text{.}\)</span> Quite a mouthful!</p>
</div></div>
</div></article></div></section></section></div></main>
</div>
</body>
</html>
